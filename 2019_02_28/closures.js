/**
 * MDN : クロージャ
 * https://developer.mozilla.org/ja/docs/Web/JavaScript/Closures
 */

// 以下MDNのドキュメントサンプルより
function init() {
  const name = "Mozilla"; // name は、init が作成するローカル変数

  function displayName() { // displayName() は内部に閉じた関数
    alert(name); // 親関数で宣言された変数を使用
  }
  displayName();
}

/**
 * ↑
 * - init内のname変数には外部からアクセスできない
 * - init内のname変数は内部からはアクセスできる
 *   - init内にあるdisplayName関数無いからもアクセスできる
 *   - 閉じられているスコープより外側の変数や関数にはアクセスできる
 */

// それでは次の場合はどうか

const counter = () => {
  // counter関数無いからしかアクセスできない変数(ローカル変数)
  let x = 0;

  // この戻り値である関数を関数Aと呼ぶことにする
  return () => {
    x++;
    // この関数Aの中からは、関数Aの外にある変数xにアクセスできる
    // 変数xはcounter関数に閉じられているので、counter関数より外からはアクセスできない
    return x;
  };
};

/**
 * 変数c1は関数Aとなる(関数Aはcounter関数内のローカル変数xにアクセスできる)
 * このとき、c1はcounter関数のローカル変数の状態を記憶している。(関数Aはcounter関数のローカル変数xにアクセスできるため)
 *
 * c1には次の関数が代入されている状態
 *
 * const c1 = () => {
 *   x++;
 *
 *   return x; // ここのxはcounter関数内のローカル変数のx
 * };
 *
 */
const c1 = counter();


/**
 * 1が返ってくる。
 * - c1()を実行すると、関数Aの1行目である「x++;」により、xが0から1にインクリメントする
 * - インクリメントしたx、つまり1がreturnされる。
 * - このとき、xはインクリメントした状態を記憶し続ける
 */
console.log('c1を実行(1回目) : ', c1());

/**
 * 2が返ってくる。
 * - c1()を実行すると、関数Aの1行目である「x++;」により、xが1から2にインクリメントする
 * - インクリメントしたx、つまり2がreturnされる。
 * - このとき、xはインクリメントした状態を記憶し続ける
 */
console.log('c1を実行(2回目) : ', c1());


/**
 * 変数c2は関数Aとなる(関数Aはcounter関数内のローカル変数xにアクセスできる)
 * - しかしc1とは独立している。
 * - 先ほどc1はxの値は2まで増えていったが、c2に入っているxは初期状態は0
 * - つまり、 「c1のx : 2」, 「c2のx : 0」の状態となっている
 * - c2のxが0の理由は、counter関数のローカル変数の初期値は0であるため。
 *
 */
const c2 = counter();

/**
 * 1が返ってくる。
 * - c2()を実行すると、関数Aの1行目である「x++;」により、xが0から1にインクリメントする
 * - インクリメントしたx、つまり1がreturnされる。
 * - このとき、xはインクリメントした状態を記憶し続ける
 *
 * 現在のc1, c2の状態
 * 「c1のx : 2」, 「c2のx : 1」
 */
console.log('c2を実行(1回目) : ', c2());


/**
 * 3が返ってくる。
 * - c1()を実行すると、関数Aの1行目である「x++;」により、xが2から3にインクリメントする
 * - インクリメントしたx、つまり3がreturnされる。
 * - このとき、xはインクリメントした状態を記憶し続ける
 *
 * 現在のc1, c2の状態
 * 「c1のx : 3」, 「c2のx : 1」
 */
console.log('c1を実行(1回目) : ', c1());

/**
 * 2が返ってくる。
 * - c2()を実行すると、関数Aの1行目である「x++;」により、xが1から2にインクリメントする
 * - インクリメントしたx、つまり2がreturnされる。
 * - このとき、xはインクリメントした状態を記憶し続ける
 *
 * 現在のc1, c2の状態
 * 「c1のx : 3」, 「c2のx : 2」
 */
console.log('c2を実行(1回目) : ', c2());


/**
 * クロージャが使われている場面の例
 *
 * ## イメージ付きやすいもの
 * - プライベート変数・関数を作成(他の言語でいうprivate, publicキーワードがJavaScriptには無いため、クロージャでprivateと同じようなことを実現する)
 *
 * ## イメージつきにくいもの(レベルが高いため、今は覚えなくても良い(僕自身うまく説明できる自信が無い))
 * - デザインパターンの1つデコレータパターンの機能を実現する
 *   - https://glorificatio.org/archives/2807
 * - ReactだとHOCという概念がある
 *   - 例: react-redux : https://github.com/reduxjs/react-redux/blob/master/src/connect/connect.js#L46
 */